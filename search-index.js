var searchIndex = {};
searchIndex['mio'] = {"items":[[0,"","mio","A fast, low-level IO library for Rust focusing on non-blocking APIs, event\nnotification, and other useful utilities for building high performance IO\napps."],[8,"Buf","","A trait for values that provide sequential read access to bytes."],[10,"remaining","","Returns the number of bytes that can be accessed from the Buf",0],[10,"bytes","","Returns a slice starting at the current Buf position and of length\nbetween 0 and `Buf::remaining()`.",0],[10,"advance","","Advance the internal cursor of the Buf",0],[10,"has_remaining","","Returns true if there are any more bytes to consume",0],[10,"read_slice","","Read bytes from the `Buf` into the given slice and advance the cursor by\nthe number of bytes read.",0],[10,"read_byte","","Read a single byte from the `Buf`",0],[8,"MutBuf","","A trait for values that provide sequential write access to bytes."],[10,"remaining","","Returns the number of bytes that can be accessed from the Buf",1],[10,"advance","","Advance the internal cursor of the Buf",1],[10,"has_remaining","","Returns true if there are any more bytes to consume",1],[10,"mut_bytes","","Returns a mutable slice starting at the current Buf position and of\nlength between 0 and `Buf::remaining()`.",1],[10,"write_slice","","Read bytes from this Buf into the given slice and advance the cursor by\nthe number of bytes read.",1],[10,"write_byte","","Write a single byte to the `MuBuf`",1],[3,"MioError","",""],[12,"kind","","",2],[3,"IoDesc","","Represents the OS's handle to the IO instance. In this case, it is the file\ndescriptor."],[12,"fd","","",3],[3,"PipeReader","",""],[3,"PipeWriter","",""],[3,"Poll","",""],[3,"EventLoop","","Single threaded IO event loop."],[3,"EventLoopConfig","","Configure EventLoop runtime details"],[12,"io_poll_timeout_ms","","",4],[12,"notify_capacity","","",4],[12,"messages_per_tick","","",4],[12,"timer_tick_ms","","",4],[12,"timer_wheel_size","","",4],[12,"timer_capacity","","",4],[3,"EventLoopSender","","Sends messages to the EventLoop from other threads."],[3,"Timeout","",""],[3,"TimerError","",""],[3,"Token","",""],[3,"PollOpt","",""],[3,"Interest","",""],[3,"ReadHint","",""],[4,"MioErrorKind","",""],[13,"Eof","","",5],[13,"WouldBlock","","",5],[13,"AddrInUse","","",5],[13,"BufUnderflow","","",5],[13,"BufOverflow","","",5],[13,"EventLoopTerminated","","",5],[13,"OtherError","","",5],[4,"NonBlock","","The result of a non-blocking operation."],[13,"Ready","","",6],[13,"WouldBlock","","",6],[5,"pipe","",""],[0,"net","","Networking primitives\n"],[5,"socket","mio::net",""],[5,"connect","",""],[5,"bind","",""],[5,"listen","",""],[5,"accept","",""],[5,"recvfrom","",""],[5,"sendto","",""],[5,"read","",""],[5,"write","",""],[5,"getpeername","",""],[5,"getsockname","",""],[0,"tcp","",""],[3,"TcpSocket","mio::net::tcp",""],[3,"TcpListener","",""],[3,"TcpAcceptor","",""],[11,"fmt","","",7],[11,"v4","","",7],[11,"v6","","",7],[11,"connect","","Connects the socket to the specified address. When the operation\ncompletes, the handler will be notified with the supplied token.",7],[11,"bind","","",7],[11,"getpeername","","",7],[11,"getsockname","","",7],[11,"desc","","",7],[11,"from_desc","","",7],[11,"read","","",7],[11,"read_slice","","",7],[11,"write","","",7],[11,"write_slice","","",7],[11,"fmt","","",8],[11,"listen","","",8],[11,"desc","","",8],[11,"from_desc","","",8],[11,"fmt","","",9],[11,"new","","",9],[11,"desc","","",9],[11,"from_desc","","",9],[6,"Output","",""],[11,"accept","","",9],[0,"udp","mio::net",""],[3,"UdpSocket","mio::net::udp",""],[11,"fmt","","",10],[11,"v4","","",10],[11,"v6","","",10],[11,"bind","","",10],[11,"connect","","",10],[11,"bound","","",10],[11,"desc","","",10],[11,"from_desc","","",10],[11,"read","","",10],[11,"read_slice","","",10],[11,"write","","",10],[11,"write_slice","","",10],[11,"send_to","","",10],[11,"recv_from","","",10],[0,"unix","mio::net",""],[3,"UnixSocket","mio::net::unix",""],[3,"UnixListener","",""],[3,"UnixAcceptor","",""],[11,"fmt","","",11],[11,"stream","","",11],[11,"connect","","",11],[11,"bind","","",11],[11,"desc","","",11],[11,"from_desc","","",11],[11,"read","","",11],[11,"read_slice","","",11],[11,"write","","",11],[11,"write_slice","","",11],[11,"fmt","","",12],[11,"listen","","",12],[11,"desc","","",12],[11,"from_desc","","",12],[11,"fmt","","",13],[11,"new","","",13],[11,"desc","","",13],[11,"from_desc","","",13],[6,"Output","",""],[11,"accept","","",13],[11,"last","nix::nix","",14],[11,"invalid_argument","","",14],[11,"eq","","",14],[11,"ne","","",14],[11,"fmt","","",14],[11,"clone","","",14],[11,"with_nix_path","std::path","",15],[11,"with_nix_path","","",16],[11,"from_i64","nix::errno::consts","",17],[11,"from_u64","","",17],[11,"eq","","",17],[11,"ne","","",17],[11,"clone","","",17],[11,"fmt","","",17],[11,"last","","",17],[11,"desc","","",17],[11,"hash","nix::fcntl::consts","",18],[11,"cmp","","",18],[11,"partial_cmp","","",18],[11,"lt","","",18],[11,"le","","",18],[11,"gt","","",18],[11,"ge","","",18],[11,"clone","","",18],[11,"eq","","",18],[11,"ne","","",18],[11,"empty","","Returns an empty set of flags.",18],[11,"all","","Returns the set containing all flags.",18],[11,"bits","","Returns the raw value of the flags currently stored.",18],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",18],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",18],[11,"is_empty","","Returns `true` if no flags are currently stored.",18],[11,"is_all","","Returns `true` if all flags are currently set.",18],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",18],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",18],[11,"insert","","Inserts the specified flags in-place.",18],[11,"remove","","Removes the specified flags in-place.",18],[11,"toggle","","Toggles the specified flags in-place.",18],[11,"bitor","","Returns the union of the two sets of flags.",18],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",18],[11,"bitand","","Returns the intersection between the two sets of flags.",18],[11,"sub","","Returns the set difference of the two sets of flags.",18],[11,"not","","Returns the complement of this set of flags.",18],[11,"hash","","",19],[11,"cmp","","",19],[11,"partial_cmp","","",19],[11,"lt","","",19],[11,"le","","",19],[11,"gt","","",19],[11,"ge","","",19],[11,"clone","","",19],[11,"eq","","",19],[11,"ne","","",19],[11,"empty","","Returns an empty set of flags.",19],[11,"all","","Returns the set containing all flags.",19],[11,"bits","","Returns the raw value of the flags currently stored.",19],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",19],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",19],[11,"is_empty","","Returns `true` if no flags are currently stored.",19],[11,"is_all","","Returns `true` if all flags are currently set.",19],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",19],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",19],[11,"insert","","Inserts the specified flags in-place.",19],[11,"remove","","Removes the specified flags in-place.",19],[11,"toggle","","Toggles the specified flags in-place.",19],[11,"bitor","","Returns the union of the two sets of flags.",19],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",19],[11,"bitand","","Returns the intersection between the two sets of flags.",19],[11,"sub","","Returns the set difference of the two sets of flags.",19],[11,"not","","Returns the complement of this set of flags.",19],[11,"hash","nix::mount","",20],[11,"cmp","","",20],[11,"partial_cmp","","",20],[11,"lt","","",20],[11,"le","","",20],[11,"gt","","",20],[11,"ge","","",20],[11,"clone","","",20],[11,"eq","","",20],[11,"ne","","",20],[11,"empty","","Returns an empty set of flags.",20],[11,"all","","Returns the set containing all flags.",20],[11,"bits","","Returns the raw value of the flags currently stored.",20],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",20],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",20],[11,"is_empty","","Returns `true` if no flags are currently stored.",20],[11,"is_all","","Returns `true` if all flags are currently set.",20],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",20],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",20],[11,"insert","","Inserts the specified flags in-place.",20],[11,"remove","","Removes the specified flags in-place.",20],[11,"toggle","","Toggles the specified flags in-place.",20],[11,"bitor","","Returns the union of the two sets of flags.",20],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",20],[11,"bitand","","Returns the intersection between the two sets of flags.",20],[11,"sub","","Returns the set difference of the two sets of flags.",20],[11,"not","","Returns the complement of this set of flags.",20],[11,"hash","","",21],[11,"cmp","","",21],[11,"partial_cmp","","",21],[11,"lt","","",21],[11,"le","","",21],[11,"gt","","",21],[11,"ge","","",21],[11,"clone","","",21],[11,"eq","","",21],[11,"ne","","",21],[11,"empty","","Returns an empty set of flags.",21],[11,"all","","Returns the set containing all flags.",21],[11,"bits","","Returns the raw value of the flags currently stored.",21],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",21],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",21],[11,"is_empty","","Returns `true` if no flags are currently stored.",21],[11,"is_all","","Returns `true` if all flags are currently set.",21],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",21],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",21],[11,"insert","","Inserts the specified flags in-place.",21],[11,"remove","","Removes the specified flags in-place.",21],[11,"toggle","","Toggles the specified flags in-place.",21],[11,"bitor","","Returns the union of the two sets of flags.",21],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",21],[11,"bitand","","Returns the intersection between the two sets of flags.",21],[11,"sub","","Returns the set difference of the two sets of flags.",21],[11,"not","","Returns the complement of this set of flags.",21],[11,"new","nix::sched","",22],[11,"set","","",22],[11,"unset","","",22],[11,"hash","nix::sys::epoll","",23],[11,"cmp","","",23],[11,"partial_cmp","","",23],[11,"lt","","",23],[11,"le","","",23],[11,"gt","","",23],[11,"ge","","",23],[11,"clone","","",23],[11,"eq","","",23],[11,"ne","","",23],[11,"empty","","Returns an empty set of flags.",23],[11,"all","","Returns the set containing all flags.",23],[11,"bits","","Returns the raw value of the flags currently stored.",23],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",23],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",23],[11,"is_empty","","Returns `true` if no flags are currently stored.",23],[11,"is_all","","Returns `true` if all flags are currently set.",23],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",23],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",23],[11,"insert","","Inserts the specified flags in-place.",23],[11,"remove","","Removes the specified flags in-place.",23],[11,"toggle","","Toggles the specified flags in-place.",23],[11,"bitor","","Returns the union of the two sets of flags.",23],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",23],[11,"bitand","","Returns the intersection between the two sets of flags.",23],[11,"sub","","Returns the set difference of the two sets of flags.",23],[11,"not","","Returns the complement of this set of flags.",23],[11,"fmt","","",23],[11,"hash","nix::sys::eventfd","",24],[11,"cmp","","",24],[11,"partial_cmp","","",24],[11,"lt","","",24],[11,"le","","",24],[11,"gt","","",24],[11,"ge","","",24],[11,"clone","","",24],[11,"eq","","",24],[11,"ne","","",24],[11,"empty","","Returns an empty set of flags.",24],[11,"all","","Returns the set containing all flags.",24],[11,"bits","","Returns the raw value of the flags currently stored.",24],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",24],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",24],[11,"is_empty","","Returns `true` if no flags are currently stored.",24],[11,"is_all","","Returns `true` if all flags are currently set.",24],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",24],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",24],[11,"insert","","Inserts the specified flags in-place.",24],[11,"remove","","Removes the specified flags in-place.",24],[11,"toggle","","Toggles the specified flags in-place.",24],[11,"bitor","","Returns the union of the two sets of flags.",24],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",24],[11,"bitand","","Returns the intersection between the two sets of flags.",24],[11,"sub","","Returns the set difference of the two sets of flags.",24],[11,"not","","Returns the complement of this set of flags.",24],[11,"fmt","nix::sys::ioctl::ffi","",25],[11,"hash","nix::sys::signal::signal","",26],[11,"cmp","","",26],[11,"partial_cmp","","",26],[11,"lt","","",26],[11,"le","","",26],[11,"gt","","",26],[11,"ge","","",26],[11,"clone","","",26],[11,"eq","","",26],[11,"ne","","",26],[11,"empty","","Returns an empty set of flags.",26],[11,"all","","Returns the set containing all flags.",26],[11,"bits","","Returns the raw value of the flags currently stored.",26],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",26],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",26],[11,"is_empty","","Returns `true` if no flags are currently stored.",26],[11,"is_all","","Returns `true` if all flags are currently set.",26],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",26],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",26],[11,"insert","","Inserts the specified flags in-place.",26],[11,"remove","","Removes the specified flags in-place.",26],[11,"toggle","","Toggles the specified flags in-place.",26],[11,"bitor","","Returns the union of the two sets of flags.",26],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",26],[11,"bitand","","Returns the intersection between the two sets of flags.",26],[11,"sub","","Returns the set difference of the two sets of flags.",26],[11,"not","","Returns the complement of this set of flags.",26],[11,"empty","nix::sys::signal","",27],[11,"add","","",27],[11,"remove","","",27],[11,"new","","",28],[11,"hash","nix::sys::socket::addr","",29],[11,"fmt","","",29],[11,"eq","","",29],[11,"ne","","",29],[11,"clone","","",29],[11,"from_std","","",30],[11,"new","","",30],[11,"ip","","Gets the IP address associated with this socket address.",30],[11,"port","","Gets the port number associated with this socket address",30],[11,"to_std","","",30],[11,"to_str","","",30],[11,"eq","","",30],[11,"hash","","",30],[11,"clone","","",30],[11,"fmt","","",30],[11,"new_v4","","Create a new IpAddr that contains an IPv4 address.",31],[11,"new_v6","","Create a new IpAddr that contains an IPv6 address.",31],[11,"from_std","","",31],[11,"to_std","","",31],[11,"fmt","","",31],[11,"new","","",32],[11,"from_std","","",32],[11,"any","","",32],[11,"octets","","",32],[11,"to_std","","",32],[11,"eq","","",32],[11,"hash","","",32],[11,"clone","","",32],[11,"fmt","","",32],[11,"new","","",33],[11,"from_std","","",33],[11,"segments","","Return the eight 16-bit segments that make up this address",33],[11,"to_std","","",33],[11,"fmt","","",33],[11,"new","","",34],[11,"path","","",34],[11,"eq","","",34],[11,"hash","","",34],[11,"clone","","",34],[11,"fmt","","",34],[11,"new_inet","","",35],[11,"new_unix","","",35],[11,"family","","",35],[11,"to_str","","",35],[11,"as_ffi_pair","","",35],[11,"eq","","",35],[11,"hash","","",35],[11,"clone","","",35],[11,"fmt","","",35],[11,"fmt","nix::sys::socket::multicast","",36],[11,"new","","",36],[11,"fmt","nix::sys::socket::sockopt","",37],[11,"get","","",37],[11,"set","","",37],[11,"fmt","","",38],[11,"get","","",38],[11,"set","","",38],[11,"fmt","","",39],[11,"get","","",39],[11,"set","","",39],[11,"fmt","","",40],[11,"get","","",40],[11,"set","","",40],[11,"fmt","","",41],[11,"get","","",41],[11,"set","","",41],[11,"fmt","","",42],[11,"get","","",42],[11,"set","","",42],[11,"fmt","","",43],[11,"get","","",43],[11,"set","","",43],[11,"blank","","",44],[11,"ffi_ptr","","",44],[11,"ffi_len","","",44],[11,"unwrap","","",44],[11,"new","","",45],[11,"ffi_ptr","","",45],[11,"ffi_len","","",45],[11,"blank","","",46],[11,"ffi_ptr","","",46],[11,"ffi_len","","",46],[11,"unwrap","","",46],[11,"new","","",47],[11,"ffi_ptr","","",47],[11,"ffi_len","","",47],[11,"blank","","",48],[11,"ffi_ptr","","",48],[11,"ffi_len","","",48],[11,"unwrap","","",48],[11,"new","","",49],[11,"ffi_ptr","","",49],[11,"ffi_len","","",49],[11,"fmt","nix::sys::socket","",50],[11,"eq","","",50],[11,"ne","","",50],[11,"hash","","",51],[11,"cmp","","",51],[11,"partial_cmp","","",51],[11,"lt","","",51],[11,"le","","",51],[11,"gt","","",51],[11,"ge","","",51],[11,"clone","","",51],[11,"eq","","",51],[11,"ne","","",51],[11,"empty","","Returns an empty set of flags.",51],[11,"all","","Returns the set containing all flags.",51],[11,"bits","","Returns the raw value of the flags currently stored.",51],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",51],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",51],[11,"is_empty","","Returns `true` if no flags are currently stored.",51],[11,"is_all","","Returns `true` if all flags are currently set.",51],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",51],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",51],[11,"insert","","Inserts the specified flags in-place.",51],[11,"remove","","Removes the specified flags in-place.",51],[11,"toggle","","Toggles the specified flags in-place.",51],[11,"bitor","","Returns the union of the two sets of flags.",51],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",51],[11,"bitand","","Returns the intersection between the two sets of flags.",51],[11,"sub","","Returns the set difference of the two sets of flags.",51],[11,"not","","Returns the complement of this set of flags.",51],[11,"fmt","","",52],[11,"hash","nix::sys::stat","",53],[11,"cmp","","",53],[11,"partial_cmp","","",53],[11,"lt","","",53],[11,"le","","",53],[11,"gt","","",53],[11,"ge","","",53],[11,"clone","","",53],[11,"eq","","",53],[11,"ne","","",53],[11,"empty","","Returns an empty set of flags.",53],[11,"all","","Returns the set containing all flags.",53],[11,"bits","","Returns the raw value of the flags currently stored.",53],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",53],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",53],[11,"is_empty","","Returns `true` if no flags are currently stored.",53],[11,"is_all","","Returns `true` if all flags are currently set.",53],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",53],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",53],[11,"insert","","Inserts the specified flags in-place.",53],[11,"remove","","Removes the specified flags in-place.",53],[11,"toggle","","Toggles the specified flags in-place.",53],[11,"bitor","","Returns the union of the two sets of flags.",53],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",53],[11,"bitand","","Returns the intersection between the two sets of flags.",53],[11,"sub","","Returns the set difference of the two sets of flags.",53],[11,"not","","Returns the complement of this set of flags.",53],[11,"hash","","",54],[11,"cmp","","",54],[11,"partial_cmp","","",54],[11,"lt","","",54],[11,"le","","",54],[11,"gt","","",54],[11,"ge","","",54],[11,"clone","","",54],[11,"eq","","",54],[11,"ne","","",54],[11,"empty","","Returns an empty set of flags.",54],[11,"all","","Returns the set containing all flags.",54],[11,"bits","","Returns the raw value of the flags currently stored.",54],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",54],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",54],[11,"is_empty","","Returns `true` if no flags are currently stored.",54],[11,"is_all","","Returns `true` if all flags are currently set.",54],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",54],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",54],[11,"insert","","Inserts the specified flags in-place.",54],[11,"remove","","Removes the specified flags in-place.",54],[11,"toggle","","Toggles the specified flags in-place.",54],[11,"bitor","","Returns the union of the two sets of flags.",54],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",54],[11,"bitand","","Returns the intersection between the two sets of flags.",54],[11,"sub","","Returns the set difference of the two sets of flags.",54],[11,"not","","Returns the complement of this set of flags.",54],[11,"fmt","","",53],[11,"hash","nix::sys::termios::ffi::consts","",55],[11,"cmp","","",55],[11,"partial_cmp","","",55],[11,"lt","","",55],[11,"le","","",55],[11,"gt","","",55],[11,"ge","","",55],[11,"clone","","",55],[11,"eq","","",55],[11,"ne","","",55],[11,"empty","","Returns an empty set of flags.",55],[11,"all","","Returns the set containing all flags.",55],[11,"bits","","Returns the raw value of the flags currently stored.",55],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",55],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",55],[11,"is_empty","","Returns `true` if no flags are currently stored.",55],[11,"is_all","","Returns `true` if all flags are currently set.",55],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",55],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",55],[11,"insert","","Inserts the specified flags in-place.",55],[11,"remove","","Removes the specified flags in-place.",55],[11,"toggle","","Toggles the specified flags in-place.",55],[11,"bitor","","Returns the union of the two sets of flags.",55],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",55],[11,"bitand","","Returns the intersection between the two sets of flags.",55],[11,"sub","","Returns the set difference of the two sets of flags.",55],[11,"not","","Returns the complement of this set of flags.",55],[11,"hash","","",56],[11,"cmp","","",56],[11,"partial_cmp","","",56],[11,"lt","","",56],[11,"le","","",56],[11,"gt","","",56],[11,"ge","","",56],[11,"clone","","",56],[11,"eq","","",56],[11,"ne","","",56],[11,"empty","","Returns an empty set of flags.",56],[11,"all","","Returns the set containing all flags.",56],[11,"bits","","Returns the raw value of the flags currently stored.",56],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",56],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",56],[11,"is_empty","","Returns `true` if no flags are currently stored.",56],[11,"is_all","","Returns `true` if all flags are currently set.",56],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",56],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",56],[11,"insert","","Inserts the specified flags in-place.",56],[11,"remove","","Removes the specified flags in-place.",56],[11,"toggle","","Toggles the specified flags in-place.",56],[11,"bitor","","Returns the union of the two sets of flags.",56],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",56],[11,"bitand","","Returns the intersection between the two sets of flags.",56],[11,"sub","","Returns the set difference of the two sets of flags.",56],[11,"not","","Returns the complement of this set of flags.",56],[11,"hash","","",57],[11,"cmp","","",57],[11,"partial_cmp","","",57],[11,"lt","","",57],[11,"le","","",57],[11,"gt","","",57],[11,"ge","","",57],[11,"clone","","",57],[11,"eq","","",57],[11,"ne","","",57],[11,"empty","","Returns an empty set of flags.",57],[11,"all","","Returns the set containing all flags.",57],[11,"bits","","Returns the raw value of the flags currently stored.",57],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",57],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",57],[11,"is_empty","","Returns `true` if no flags are currently stored.",57],[11,"is_all","","Returns `true` if all flags are currently set.",57],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",57],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",57],[11,"insert","","Inserts the specified flags in-place.",57],[11,"remove","","Removes the specified flags in-place.",57],[11,"toggle","","Toggles the specified flags in-place.",57],[11,"bitor","","Returns the union of the two sets of flags.",57],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",57],[11,"bitand","","Returns the intersection between the two sets of flags.",57],[11,"sub","","Returns the set difference of the two sets of flags.",57],[11,"not","","Returns the complement of this set of flags.",57],[11,"hash","","",58],[11,"cmp","","",58],[11,"partial_cmp","","",58],[11,"lt","","",58],[11,"le","","",58],[11,"gt","","",58],[11,"ge","","",58],[11,"clone","","",58],[11,"eq","","",58],[11,"ne","","",58],[11,"empty","","Returns an empty set of flags.",58],[11,"all","","Returns the set containing all flags.",58],[11,"bits","","Returns the raw value of the flags currently stored.",58],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",58],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",58],[11,"is_empty","","Returns `true` if no flags are currently stored.",58],[11,"is_all","","Returns `true` if all flags are currently set.",58],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",58],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",58],[11,"insert","","Inserts the specified flags in-place.",58],[11,"remove","","Removes the specified flags in-place.",58],[11,"toggle","","Toggles the specified flags in-place.",58],[11,"bitor","","Returns the union of the two sets of flags.",58],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",58],[11,"bitand","","Returns the intersection between the two sets of flags.",58],[11,"sub","","Returns the set difference of the two sets of flags.",58],[11,"not","","Returns the complement of this set of flags.",58],[11,"sysname","nix::sys::utsname","",59],[11,"nodename","","",59],[11,"release","","",59],[11,"version","","",59],[11,"machine","","",59],[11,"hash","nix::sys::wait","",60],[11,"cmp","","",60],[11,"partial_cmp","","",60],[11,"lt","","",60],[11,"le","","",60],[11,"gt","","",60],[11,"ge","","",60],[11,"clone","","",60],[11,"eq","","",60],[11,"ne","","",60],[11,"empty","","Returns an empty set of flags.",60],[11,"all","","Returns the set containing all flags.",60],[11,"bits","","Returns the raw value of the flags currently stored.",60],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",60],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",60],[11,"is_empty","","Returns `true` if no flags are currently stored.",60],[11,"is_all","","Returns `true` if all flags are currently set.",60],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",60],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",60],[11,"insert","","Inserts the specified flags in-place.",60],[11,"remove","","Removes the specified flags in-place.",60],[11,"toggle","","Toggles the specified flags in-place.",60],[11,"bitor","","Returns the union of the two sets of flags.",60],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",60],[11,"bitand","","Returns the intersection between the two sets of flags.",60],[11,"sub","","Returns the set difference of the two sets of flags.",60],[11,"not","","Returns the complement of this set of flags.",60],[11,"as_slice","nix::sys::uio","",61],[11,"from_slice","","",61],[11,"from_mut_slice","","",61],[11,"is_child","nix::unistd","",62],[11,"is_parent","","",62],[11,"as_ext_str","std::ffi::os_str","",63],[8,"Socket","mio::net",""],[11,"linger","","",64],[11,"set_linger","","",64],[11,"set_reuseaddr","","",64],[11,"set_reuseport","","",64],[11,"set_tcp_nodelay","","",64],[8,"MulticastSocket","",""],[11,"join_multicast_group","","",65],[11,"leave_multicast_group","","",65],[11,"set_multicast_ttl","","",65],[8,"UnconnectedSocket","",""],[10,"send_to","","",66],[10,"recv_from","","",66],[0,"util","mio","Utilities for non-blocking IO programs"],[3,"BoundedQueue","mio::util",""],[3,"Slab","","A preallocated chunk of memory for storing objects of the same type."],[11,"with_capacity","","",67],[11,"push","","",67],[11,"pop","","",67],[11,"clone","","",67],[11,"new","","",68],[11,"new_starting_at","","",68],[11,"count","","",68],[11,"is_empty","","",68],[11,"remaining","","",68],[11,"has_remaining","","",68],[11,"contains","","",68],[11,"get","","",68],[11,"get_mut","","",68],[11,"insert","","",68],[11,"remove","","Releases the given slot",68],[11,"index","","",68],[11,"index_mut","","",68],[11,"fmt","","",68],[11,"drop","","",68],[11,"clone","mio","",2],[11,"eq","","",2],[11,"ne","","",2],[11,"fmt","","",2],[11,"clone","","",5],[11,"eq","","",5],[11,"ne","","",5],[11,"fmt","","",5],[11,"eof","","",2],[11,"buf_underflow","","",2],[11,"buf_overflow","","",2],[11,"other","","",2],[11,"from_nix_error","","",2],[11,"is_eof","","",2],[11,"is_would_block","","",2],[11,"is_buf_underflow","","",2],[11,"is_buf_overflow","","",2],[11,"as_io_error","","",2],[11,"fmt","","",4],[11,"clone","","",4],[11,"default","","",4],[11,"fmt","","",69],[11,"new","","Initializes a new event loop using default configuration settings. The\nevent loop will not be running yet.",69],[11,"configured","","",69],[11,"channel","","Returns a sender that allows sending messages to the event loop in a\nthread-safe way, waking up the event loop if needed.",69],[11,"timeout","","Schedules a timeout after the requested time interval. When the\nduration has been reached,\n[Handler::timeout](trait.Handler.html#method.timeout) will be invoked\npassing in the supplied token.",69],[11,"clear_timeout","","If the supplied timeout has not been triggered, cancel it such that it\nwill not be triggered in the future.",69],[11,"shutdown","","Tells the event loop to exit after it is done handling all events in the\ncurrent iteration.",69],[11,"register","","Registers an IO handle with the event loop.",69],[11,"register_opt","","Registers an IO handle with the event loop.",69],[11,"reregister","","Re-Registers an IO handle with the event loop.",69],[11,"run","","Keep spinning the event loop indefinitely, and notify the handler whenever\nany of the registered handles are ready.",69],[11,"deregister","","Deregisters an IO handle with the event loop.",69],[11,"run_once","","Spin the event loop once, with a timeout of one second, and notify the\nhandler if any of the registered handles become ready during that\ntime.",69],[11,"clone","","",70],[11,"fmt","","",70],[11,"send","","",70],[11,"fmt","","",6],[11,"would_block","","",6],[11,"unwrap","","",6],[11,"desc","","",71],[11,"from_desc","","",71],[11,"desc","","",72],[11,"from_desc","","",72],[11,"read","","",71],[11,"read_slice","","",71],[11,"write","","",72],[11,"write_slice","","",72],[11,"fmt","","",3],[11,"desc","","",3],[11,"drop","","",3],[11,"cmp","","",73],[11,"partial_cmp","","",73],[11,"lt","","",73],[11,"le","","",73],[11,"gt","","",73],[11,"ge","","",73],[11,"clone","","",73],[11,"eq","","",73],[11,"ne","","",73],[11,"edge","","",73],[11,"empty","","",73],[11,"level","","",73],[11,"oneshot","","",73],[11,"all","","",73],[11,"is_edge","","",73],[11,"is_level","","",73],[11,"is_oneshot","","",73],[11,"bits","","",73],[11,"contains","","",73],[11,"insert","","",73],[11,"remove","","",73],[11,"bitor","","",73],[11,"bitxor","","",73],[11,"bitand","","",73],[11,"sub","","",73],[11,"not","","",73],[11,"fmt","","",73],[11,"cmp","","",74],[11,"partial_cmp","","",74],[11,"lt","","",74],[11,"le","","",74],[11,"gt","","",74],[11,"ge","","",74],[11,"clone","","",74],[11,"eq","","",74],[11,"ne","","",74],[11,"none","","",74],[11,"readable","","",74],[11,"writable","","",74],[11,"error","","",74],[11,"hup","","",74],[11,"hinted","","",74],[11,"all","","",74],[11,"is_readable","","",74],[11,"is_writable","","",74],[11,"is_error","","",74],[11,"is_hup","","",74],[11,"is_hinted","","",74],[11,"insert","","",74],[11,"remove","","",74],[11,"bits","","",74],[11,"contains","","",74],[11,"bitor","","",74],[11,"bitxor","","",74],[11,"bitand","","",74],[11,"sub","","",74],[11,"not","","",74],[11,"fmt","","",74],[11,"cmp","","",75],[11,"partial_cmp","","",75],[11,"lt","","",75],[11,"le","","",75],[11,"gt","","",75],[11,"ge","","",75],[11,"clone","","",75],[11,"eq","","",75],[11,"ne","","",75],[11,"none","","",75],[11,"all","","",75],[11,"data","","",75],[11,"hup","","",75],[11,"error","","",75],[11,"is_data","","",75],[11,"is_hup","","",75],[11,"is_error","","",75],[11,"insert","","",75],[11,"remove","","",75],[11,"contains","","",75],[11,"bits","","",75],[11,"bitor","","",75],[11,"bitxor","","",75],[11,"bitand","","",75],[11,"sub","","",75],[11,"not","","",75],[11,"fmt","","",75],[11,"hash","","",76],[11,"eq","","",76],[11,"ne","","",76],[11,"fmt","","",76],[11,"clone","","",76],[11,"as_usize","","",76],[11,"fmt","","",3],[11,"desc","","",3],[11,"drop","","",3],[11,"new","","",77],[11,"register","","",77],[11,"reregister","","",77],[11,"deregister","","",77],[11,"poll","","",77],[11,"event","","",77],[11,"iter","","",77],[11,"fmt","","",77],[11,"fmt","","",78],[0,"buf","",""],[8,"Buf","mio::buf","A trait for values that provide sequential read access to bytes."],[10,"remaining","","Returns the number of bytes that can be accessed from the Buf",0],[10,"bytes","","Returns a slice starting at the current Buf position and of length\nbetween 0 and `Buf::remaining()`.",0],[10,"advance","","Advance the internal cursor of the Buf",0],[10,"has_remaining","","Returns true if there are any more bytes to consume",0],[10,"read_slice","","Read bytes from the `Buf` into the given slice and advance the cursor by\nthe number of bytes read.",0],[10,"read_byte","","Read a single byte from the `Buf`",0],[8,"MutBuf","","A trait for values that provide sequential write access to bytes."],[10,"remaining","","Returns the number of bytes that can be accessed from the Buf",1],[10,"advance","","Advance the internal cursor of the Buf",1],[10,"has_remaining","","Returns true if there are any more bytes to consume",1],[10,"mut_bytes","","Returns a mutable slice starting at the current Buf position and of\nlength between 0 and `Buf::remaining()`.",1],[10,"write_slice","","Read bytes from this Buf into the given slice and advance the cursor by\nthe number of bytes read.",1],[10,"write_byte","","Write a single byte to the `MuBuf`",1],[11,"from_slice","bytes::byte_buf","Create a new `ByteBuf` by copying the contents of the given slice.",79],[11,"mut_with_capacity","","",79],[11,"none","","",79],[11,"from_mem_ref","","",79],[11,"capacity","","",79],[11,"flip","","",79],[11,"read_slice","","",79],[11,"to_seq_byte_str","","",79],[11,"to_bytes","","",79],[11,"new","bytes::alloc","",80],[11,"none","","",80],[11,"is_none","","",80],[11,"ptr","","",80],[11,"bytes","","",80],[11,"bytes_mut","","",80],[11,"clone","","",80],[11,"drop","","",80],[11,"allocate","","",81],[11,"deallocate","","",81],[11,"allocate","","",81],[11,"deallocate","","",81],[11,"remaining","bytes::byte_buf","",79],[11,"bytes","","",79],[11,"advance","","",79],[11,"read_slice","","",79],[11,"from_mem_ref","","",82],[11,"to_seq_byte_str","","",82],[11,"to_bytes","","",82],[11,"remaining","","",82],[11,"bytes","","",82],[11,"advance","","",82],[11,"read_slice","","",82],[11,"capacity","","",83],[11,"flip","","",83],[11,"clear","","",83],[11,"write_slice","","",83],[11,"remaining","","",83],[11,"advance","","",83],[11,"mut_bytes","","",83],[11,"from_slice","bytes::byte_str","Create a new `SeqByteStr` from a byte slice.",84],[11,"from_mem_ref","","Creates a new `SeqByteStr` from a `MemRef`, an offset, and a length.",84],[6,"Buf","mio::buf",""],[11,"buf","bytes::byte_str","",84],[11,"concat","","",84],[11,"len","","",84],[11,"slice","","",84],[11,"to_bytes","","",84],[6,"Output","mio::buf",""],[11,"index","bytes::byte_str","",84],[11,"clone","","",84],[11,"clone","","",85],[11,"zero","","",85],[11,"from_slice","","",85],[6,"Buf","mio::buf",""],[11,"buf","bytes::byte_str","",85],[11,"concat","","",85],[11,"len","","",85],[11,"slice","","",85],[11,"split_at","","",85],[11,"to_bytes","","",85],[6,"Output","mio::buf",""],[11,"index","bytes::byte_str","",85],[11,"clone","","",86],[11,"remaining","","",86],[11,"bytes","","",86],[11,"advance","","",86],[11,"from_slice","bytes::bytes","",87],[11,"of","","",87],[11,"empty","","",87],[11,"downcast_ref","","If the underlying `ByteStr` is of type `B`, returns a reference to it\notherwise None.",87],[11,"try_unwrap","","If the underlying `ByteStr` is of type `B`, returns the unwraped value,\notherwise, returns the original `Bytes` as `Err`.",87],[6,"Buf","mio::buf",""],[11,"buf","bytes::bytes","",87],[11,"concat","","",87],[11,"len","","",87],[11,"slice","","",87],[11,"split_at","","",87],[11,"to_bytes","","",87],[6,"Output","mio::buf",""],[11,"index","bytes::bytes","",87],[11,"clone","","",87],[11,"drop","","",87],[11,"new","bytes::ring","",88],[11,"is_full","","",88],[11,"is_empty","","",88],[11,"capacity","","",88],[11,"reader","","",88],[11,"writer","","",88],[11,"clone","","",88],[11,"fmt","","",88],[11,"drop","","",88],[11,"remaining","","",89],[11,"bytes","","",89],[11,"advance","","",89],[11,"remaining","","",90],[11,"advance","","",90],[11,"mut_bytes","","",90],[11,"from_slice","bytes::rope","",91],[11,"of","","Returns a Rope consisting of the supplied Bytes as a single segment.",91],[11,"len","","",91],[11,"is_empty","","",91],[6,"Buf","mio::buf",""],[11,"buf","bytes::rope","",91],[11,"concat","","",91],[11,"len","","",91],[11,"slice","","",91],[11,"to_bytes","","",91],[6,"Output","mio::buf",""],[11,"index","bytes::rope","",91],[11,"clone","","",91],[6,"Error","mio::buf",""],[11,"remaining","bytes::rope","",92],[11,"bytes","","",92],[11,"advance","","",92],[6,"Item","mio::buf",""],[11,"next","bytes::rope","",93],[11,"wrap","bytes::slice","",94],[11,"remaining","","",94],[11,"bytes","","",94],[11,"advance","","",94],[11,"wrap","","",95],[11,"remaining","","",95],[11,"advance","","",95],[11,"mut_bytes","","",95],[6,"Error","mio::buf",""],[6,"Error","",""],[6,"Error","",""],[6,"Error","",""],[6,"Error","",""],[6,"Error","",""],[6,"Error","",""],[11,"remaining","alloc::boxed","",96],[11,"bytes","","",96],[11,"advance","","",96],[11,"read_slice","","",96],[11,"fmt","bytes","",97],[3,"ByteBuf","mio::buf","A `Buf` backed by a contiguous region of memory."],[3,"MutByteBuf","",""],[3,"RingBuf","","Buf backed by a continous chunk of memory. Maintains a read cursor and a\nwrite cursor. When reads and writes reach the end of the allocated buffer,\nwraps around to the start."],[3,"RingBufReader","",""],[3,"RingBufWriter","",""],[3,"SliceBuf","",""],[3,"MutSliceBuf","",""],[6,"MioResult","mio",""],[6,"TimerResult","",""],[8,"Handler","",""],[11,"readable","","",98],[11,"writable","","",98],[11,"notify","","",98],[11,"timeout","","",98],[8,"FromIoDesc","",""],[10,"from_desc","","",99],[8,"IoReader","",""],[10,"read","","",100],[10,"read_slice","","",100],[8,"IoWriter","",""],[10,"write","","",101],[10,"write_slice","","",101],[8,"IoAcceptor","",""],[16,"Output","mio::IoAcceptor",""],[10,"accept","mio","",102],[8,"IoHandle","",""],[10,"desc","","",103],[11,"readable","","",98],[11,"writable","","",98],[11,"notify","","",98],[11,"timeout","","",98]],"paths":[[8,"Buf"],[8,"MutBuf"],[3,"MioError"],[3,"IoDesc"],[3,"EventLoopConfig"],[4,"MioErrorKind"],[4,"NonBlock"],[3,"TcpSocket"],[3,"TcpListener"],[3,"TcpAcceptor"],[3,"UdpSocket"],[3,"UnixSocket"],[3,"UnixListener"],[3,"UnixAcceptor"],[4,"NixError"],[3,"Path"],[3,"PathBuf"],[4,"Errno"],[3,"OFlag"],[3,"FdFlag"],[3,"MsFlags"],[3,"MntFlags"],[3,"CpuSet"],[3,"EpollEventKind"],[3,"EventFdFlag"],[3,"Winsize"],[3,"SockFlag"],[3,"SigSet"],[3,"SigAction"],[4,"AddressFamily"],[4,"InetAddr"],[4,"IpAddr"],[3,"Ipv4Addr"],[3,"Ipv6Addr"],[3,"UnixAddr"],[4,"SockAddr"],[3,"ip_mreq"],[3,"ReuseAddr"],[3,"ReusePort"],[3,"TcpNoDelay"],[3,"Linger"],[3,"IpAddMembership"],[3,"IpDropMembership"],[3,"IpMulticastTtl"],[3,"GetStruct"],[3,"SetStruct"],[3,"GetBool"],[3,"SetBool"],[3,"GetU8"],[3,"SetU8"],[4,"SockType"],[3,"SockFlag"],[3,"linger"],[3,"SFlag"],[3,"Mode"],[3,"InputFlags"],[3,"OutputFlags"],[3,"ControlFlags"],[3,"LocalFlags"],[3,"UtsName"],[3,"WaitPidFlag"],[3,"IoVec"],[4,"Fork"],[3,"OsStr"],[8,"Socket"],[8,"MulticastSocket"],[8,"UnconnectedSocket"],[3,"BoundedQueue"],[3,"Slab"],[3,"EventLoop"],[3,"EventLoopSender"],[3,"PipeReader"],[3,"PipeWriter"],[3,"PollOpt"],[3,"Interest"],[3,"ReadHint"],[3,"Token"],[3,"Poll"],[3,"TimerError"],[3,"ByteBuf"],[3,"MemRef"],[3,"Heap"],[3,"ROByteBuf"],[3,"MutByteBuf"],[3,"SeqByteStr"],[3,"SmallByteStr"],[3,"SmallByteStrBuf"],[3,"Bytes"],[3,"RingBuf"],[3,"RingBufReader"],[3,"RingBufWriter"],[3,"Rope"],[3,"RopeBuf"],[3,"PieceIter"],[3,"SliceBuf"],[3,"MutSliceBuf"],[3,"Box"],[4,"BufError"],[8,"Handler"],[8,"FromIoDesc"],[8,"IoReader"],[8,"IoWriter"],[8,"IoAcceptor"],[8,"IoHandle"]]};
initSearch(searchIndex);
