var searchIndex = {};
searchIndex['mio'] = {"items":[[0,"","mio","A fast, low-level IO library for Rust focusing on non-blocking APIs, event\nnotification, and other useful utilities for building high performance IO\napps."],[8,"Buf","","A trait for values that provide sequential read access to bytes."],[10,"remaining","","Returns the number of bytes that can be accessed from the Buf",0],[10,"bytes","","Returns a slice starting at the current Buf position and of length\nbetween 0 and `Buf::remaining()`.",0],[10,"advance","","Advance the internal cursor of the Buf",0],[10,"has_remaining","","Returns true if there are any more bytes to consume",0],[10,"read_slice","","Read bytes from the `Buf` into the given slice and advance the cursor by\nthe number of bytes read.",0],[10,"read_byte","","Read a single byte from the `Buf`",0],[8,"MutBuf","","A trait for values that provide sequential write access to bytes."],[10,"remaining","","Returns the number of bytes that can be accessed from the Buf",1],[10,"advance","","Advance the internal cursor of the Buf",1],[10,"has_remaining","","Returns true if there are any more bytes to consume",1],[10,"mut_bytes","","Returns a mutable slice starting at the current Buf position and of\nlength between 0 and `Buf::remaining()`.",1],[10,"write_slice","","Read bytes from this Buf into the given slice and advance the cursor by\nthe number of bytes read.",1],[10,"write_byte","","Write a single byte to the `MuBuf`",1],[3,"MioError","",""],[12,"kind","","",2],[3,"Io","",""],[3,"PipeReader","",""],[3,"PipeWriter","",""],[3,"Poll","",""],[3,"EventLoop","","Single threaded IO event loop."],[3,"EventLoopConfig","","Configure EventLoop runtime details"],[12,"io_poll_timeout_ms","","",3],[12,"notify_capacity","","",3],[12,"messages_per_tick","","",3],[12,"timer_tick_ms","","",3],[12,"timer_wheel_size","","",3],[12,"timer_capacity","","",3],[3,"EventLoopSender","","Sends messages to the EventLoop from other threads."],[3,"Timeout","",""],[3,"TimerError","",""],[3,"Token","",""],[3,"PollOpt","",""],[3,"Interest","",""],[3,"ReadHint","",""],[4,"MioErrorKind","",""],[13,"Eof","","",4],[13,"WouldBlock","","",4],[13,"AddrInUse","","",4],[13,"BufUnderflow","","",4],[13,"BufOverflow","","",4],[13,"EventLoopTerminated","","",4],[13,"OtherError","","",4],[4,"NonBlock","","The result of a non-blocking operation."],[13,"Ready","","",5],[13,"WouldBlock","","",5],[5,"pipe","",""],[0,"net","","Networking primitives\n"],[0,"tcp","mio::net",""],[3,"TcpSocket","mio::net::tcp",""],[3,"TcpListener","",""],[3,"TcpAcceptor","",""],[11,"fmt","","",6],[11,"v4","","",6],[11,"v6","","",6],[11,"connect","","Connects the socket to the specified address. When the operation\ncompletes, the handler will be notified with the supplied token.",6],[11,"bind","","",6],[11,"getpeername","","",6],[11,"getsockname","","",6],[11,"fd","","",6],[11,"from_fd","","",6],[11,"read_slice","","",6],[11,"write_slice","","",6],[11,"fmt","","",7],[11,"listen","","",7],[11,"fd","","",7],[11,"from_fd","","",7],[11,"fmt","","",8],[11,"new","","",8],[11,"fd","","",8],[11,"from_fd","","",8],[6,"Output","",""],[11,"accept","","",8],[0,"udp","mio::net",""],[3,"UdpSocket","mio::net::udp",""],[11,"fmt","","",9],[11,"v4","","",9],[11,"v6","","",9],[11,"bind","","",9],[11,"connect","","",9],[11,"bound","","",9],[11,"fd","","",9],[11,"from_fd","","",9],[11,"read_slice","","",9],[11,"write_slice","","",9],[11,"send_to","","",9],[11,"recv_from","","",9],[0,"unix","mio::net",""],[3,"UnixSocket","mio::net::unix",""],[3,"UnixListener","",""],[3,"UnixAcceptor","",""],[11,"fmt","","",10],[11,"stream","","",10],[11,"connect","","",10],[11,"bind","","",10],[11,"fd","","",10],[11,"from_fd","","",10],[11,"read_slice","","",10],[11,"write_slice","","",10],[11,"fmt","","",11],[11,"listen","","",11],[11,"fd","","",11],[11,"from_fd","","",11],[11,"fmt","","",12],[11,"new","","",12],[11,"fd","","",12],[11,"from_fd","","",12],[6,"Output","",""],[11,"accept","","",12],[11,"last","nix::nix","",13],[11,"invalid_argument","","",13],[11,"eq","","",13],[11,"ne","","",13],[11,"fmt","","",13],[11,"clone","","",13],[11,"with_nix_path","std::path","",14],[11,"with_nix_path","","",15],[11,"from_i64","nix::errno::consts","",16],[11,"from_u64","","",16],[11,"eq","","",16],[11,"ne","","",16],[11,"clone","","",16],[11,"fmt","","",16],[11,"last","","",16],[11,"desc","","",16],[11,"hash","nix::fcntl::consts","",17],[11,"cmp","","",17],[11,"partial_cmp","","",17],[11,"lt","","",17],[11,"le","","",17],[11,"gt","","",17],[11,"ge","","",17],[11,"clone","","",17],[11,"eq","","",17],[11,"ne","","",17],[11,"empty","","Returns an empty set of flags.",17],[11,"all","","Returns the set containing all flags.",17],[11,"bits","","Returns the raw value of the flags currently stored.",17],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",17],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",17],[11,"is_empty","","Returns `true` if no flags are currently stored.",17],[11,"is_all","","Returns `true` if all flags are currently set.",17],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",17],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",17],[11,"insert","","Inserts the specified flags in-place.",17],[11,"remove","","Removes the specified flags in-place.",17],[11,"toggle","","Toggles the specified flags in-place.",17],[11,"bitor","","Returns the union of the two sets of flags.",17],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",17],[11,"bitand","","Returns the intersection between the two sets of flags.",17],[11,"sub","","Returns the set difference of the two sets of flags.",17],[11,"not","","Returns the complement of this set of flags.",17],[11,"hash","","",18],[11,"cmp","","",18],[11,"partial_cmp","","",18],[11,"lt","","",18],[11,"le","","",18],[11,"gt","","",18],[11,"ge","","",18],[11,"clone","","",18],[11,"eq","","",18],[11,"ne","","",18],[11,"empty","","Returns an empty set of flags.",18],[11,"all","","Returns the set containing all flags.",18],[11,"bits","","Returns the raw value of the flags currently stored.",18],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",18],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",18],[11,"is_empty","","Returns `true` if no flags are currently stored.",18],[11,"is_all","","Returns `true` if all flags are currently set.",18],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",18],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",18],[11,"insert","","Inserts the specified flags in-place.",18],[11,"remove","","Removes the specified flags in-place.",18],[11,"toggle","","Toggles the specified flags in-place.",18],[11,"bitor","","Returns the union of the two sets of flags.",18],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",18],[11,"bitand","","Returns the intersection between the two sets of flags.",18],[11,"sub","","Returns the set difference of the two sets of flags.",18],[11,"not","","Returns the complement of this set of flags.",18],[11,"hash","nix::mount","",19],[11,"cmp","","",19],[11,"partial_cmp","","",19],[11,"lt","","",19],[11,"le","","",19],[11,"gt","","",19],[11,"ge","","",19],[11,"clone","","",19],[11,"eq","","",19],[11,"ne","","",19],[11,"empty","","Returns an empty set of flags.",19],[11,"all","","Returns the set containing all flags.",19],[11,"bits","","Returns the raw value of the flags currently stored.",19],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",19],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",19],[11,"is_empty","","Returns `true` if no flags are currently stored.",19],[11,"is_all","","Returns `true` if all flags are currently set.",19],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",19],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",19],[11,"insert","","Inserts the specified flags in-place.",19],[11,"remove","","Removes the specified flags in-place.",19],[11,"toggle","","Toggles the specified flags in-place.",19],[11,"bitor","","Returns the union of the two sets of flags.",19],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",19],[11,"bitand","","Returns the intersection between the two sets of flags.",19],[11,"sub","","Returns the set difference of the two sets of flags.",19],[11,"not","","Returns the complement of this set of flags.",19],[11,"hash","","",20],[11,"cmp","","",20],[11,"partial_cmp","","",20],[11,"lt","","",20],[11,"le","","",20],[11,"gt","","",20],[11,"ge","","",20],[11,"clone","","",20],[11,"eq","","",20],[11,"ne","","",20],[11,"empty","","Returns an empty set of flags.",20],[11,"all","","Returns the set containing all flags.",20],[11,"bits","","Returns the raw value of the flags currently stored.",20],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",20],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",20],[11,"is_empty","","Returns `true` if no flags are currently stored.",20],[11,"is_all","","Returns `true` if all flags are currently set.",20],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",20],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",20],[11,"insert","","Inserts the specified flags in-place.",20],[11,"remove","","Removes the specified flags in-place.",20],[11,"toggle","","Toggles the specified flags in-place.",20],[11,"bitor","","Returns the union of the two sets of flags.",20],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",20],[11,"bitand","","Returns the intersection between the two sets of flags.",20],[11,"sub","","Returns the set difference of the two sets of flags.",20],[11,"not","","Returns the complement of this set of flags.",20],[11,"new","nix::sched","",21],[11,"set","","",21],[11,"unset","","",21],[11,"hash","nix::sys::epoll","",22],[11,"cmp","","",22],[11,"partial_cmp","","",22],[11,"lt","","",22],[11,"le","","",22],[11,"gt","","",22],[11,"ge","","",22],[11,"clone","","",22],[11,"eq","","",22],[11,"ne","","",22],[11,"empty","","Returns an empty set of flags.",22],[11,"all","","Returns the set containing all flags.",22],[11,"bits","","Returns the raw value of the flags currently stored.",22],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",22],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",22],[11,"is_empty","","Returns `true` if no flags are currently stored.",22],[11,"is_all","","Returns `true` if all flags are currently set.",22],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",22],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",22],[11,"insert","","Inserts the specified flags in-place.",22],[11,"remove","","Removes the specified flags in-place.",22],[11,"toggle","","Toggles the specified flags in-place.",22],[11,"bitor","","Returns the union of the two sets of flags.",22],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",22],[11,"bitand","","Returns the intersection between the two sets of flags.",22],[11,"sub","","Returns the set difference of the two sets of flags.",22],[11,"not","","Returns the complement of this set of flags.",22],[11,"fmt","","",22],[11,"hash","nix::sys::eventfd","",23],[11,"cmp","","",23],[11,"partial_cmp","","",23],[11,"lt","","",23],[11,"le","","",23],[11,"gt","","",23],[11,"ge","","",23],[11,"clone","","",23],[11,"eq","","",23],[11,"ne","","",23],[11,"empty","","Returns an empty set of flags.",23],[11,"all","","Returns the set containing all flags.",23],[11,"bits","","Returns the raw value of the flags currently stored.",23],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",23],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",23],[11,"is_empty","","Returns `true` if no flags are currently stored.",23],[11,"is_all","","Returns `true` if all flags are currently set.",23],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",23],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",23],[11,"insert","","Inserts the specified flags in-place.",23],[11,"remove","","Removes the specified flags in-place.",23],[11,"toggle","","Toggles the specified flags in-place.",23],[11,"bitor","","Returns the union of the two sets of flags.",23],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",23],[11,"bitand","","Returns the intersection between the two sets of flags.",23],[11,"sub","","Returns the set difference of the two sets of flags.",23],[11,"not","","Returns the complement of this set of flags.",23],[11,"fmt","nix::sys::ioctl::ffi","",24],[11,"hash","nix::sys::signal::signal","",25],[11,"cmp","","",25],[11,"partial_cmp","","",25],[11,"lt","","",25],[11,"le","","",25],[11,"gt","","",25],[11,"ge","","",25],[11,"clone","","",25],[11,"eq","","",25],[11,"ne","","",25],[11,"empty","","Returns an empty set of flags.",25],[11,"all","","Returns the set containing all flags.",25],[11,"bits","","Returns the raw value of the flags currently stored.",25],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",25],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",25],[11,"is_empty","","Returns `true` if no flags are currently stored.",25],[11,"is_all","","Returns `true` if all flags are currently set.",25],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",25],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",25],[11,"insert","","Inserts the specified flags in-place.",25],[11,"remove","","Removes the specified flags in-place.",25],[11,"toggle","","Toggles the specified flags in-place.",25],[11,"bitor","","Returns the union of the two sets of flags.",25],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",25],[11,"bitand","","Returns the intersection between the two sets of flags.",25],[11,"sub","","Returns the set difference of the two sets of flags.",25],[11,"not","","Returns the complement of this set of flags.",25],[11,"empty","nix::sys::signal","",26],[11,"add","","",26],[11,"remove","","",26],[11,"new","","",27],[11,"hash","nix::sys::socket::addr","",28],[11,"fmt","","",28],[11,"eq","","",28],[11,"ne","","",28],[11,"clone","","",28],[11,"from_std","","",29],[11,"new","","",29],[11,"ip","","Gets the IP address associated with this socket address.",29],[11,"port","","Gets the port number associated with this socket address",29],[11,"to_std","","",29],[11,"to_str","","",29],[11,"eq","","",29],[11,"hash","","",29],[11,"clone","","",29],[11,"fmt","","",29],[11,"new_v4","","Create a new IpAddr that contains an IPv4 address.",30],[11,"new_v6","","Create a new IpAddr that contains an IPv6 address.",30],[11,"from_std","","",30],[11,"to_std","","",30],[11,"fmt","","",30],[11,"new","","",31],[11,"from_std","","",31],[11,"any","","",31],[11,"octets","","",31],[11,"to_std","","",31],[11,"eq","","",31],[11,"hash","","",31],[11,"clone","","",31],[11,"fmt","","",31],[11,"new","","",32],[11,"from_std","","",32],[11,"segments","","Return the eight 16-bit segments that make up this address",32],[11,"to_std","","",32],[11,"fmt","","",32],[11,"new","","",33],[11,"path","","",33],[11,"eq","","",33],[11,"hash","","",33],[11,"clone","","",33],[11,"fmt","","",33],[11,"new_inet","","",34],[11,"new_unix","","",34],[11,"family","","",34],[11,"to_str","","",34],[11,"as_ffi_pair","","",34],[11,"eq","","",34],[11,"hash","","",34],[11,"clone","","",34],[11,"fmt","","",34],[11,"fmt","nix::sys::socket::multicast","",35],[11,"new","","",35],[11,"fmt","nix::sys::socket::sockopt","",36],[11,"get","","",36],[11,"set","","",36],[11,"fmt","","",37],[11,"get","","",37],[11,"set","","",37],[11,"fmt","","",38],[11,"get","","",38],[11,"set","","",38],[11,"fmt","","",39],[11,"get","","",39],[11,"set","","",39],[11,"fmt","","",40],[11,"get","","",40],[11,"set","","",40],[11,"fmt","","",41],[11,"get","","",41],[11,"set","","",41],[11,"fmt","","",42],[11,"get","","",42],[11,"set","","",42],[11,"blank","","",43],[11,"ffi_ptr","","",43],[11,"ffi_len","","",43],[11,"unwrap","","",43],[11,"new","","",44],[11,"ffi_ptr","","",44],[11,"ffi_len","","",44],[11,"blank","","",45],[11,"ffi_ptr","","",45],[11,"ffi_len","","",45],[11,"unwrap","","",45],[11,"new","","",46],[11,"ffi_ptr","","",46],[11,"ffi_len","","",46],[11,"blank","","",47],[11,"ffi_ptr","","",47],[11,"ffi_len","","",47],[11,"unwrap","","",47],[11,"new","","",48],[11,"ffi_ptr","","",48],[11,"ffi_len","","",48],[11,"fmt","nix::sys::socket","",49],[11,"eq","","",49],[11,"ne","","",49],[11,"hash","","",50],[11,"cmp","","",50],[11,"partial_cmp","","",50],[11,"lt","","",50],[11,"le","","",50],[11,"gt","","",50],[11,"ge","","",50],[11,"clone","","",50],[11,"eq","","",50],[11,"ne","","",50],[11,"empty","","Returns an empty set of flags.",50],[11,"all","","Returns the set containing all flags.",50],[11,"bits","","Returns the raw value of the flags currently stored.",50],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",50],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",50],[11,"is_empty","","Returns `true` if no flags are currently stored.",50],[11,"is_all","","Returns `true` if all flags are currently set.",50],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",50],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",50],[11,"insert","","Inserts the specified flags in-place.",50],[11,"remove","","Removes the specified flags in-place.",50],[11,"toggle","","Toggles the specified flags in-place.",50],[11,"bitor","","Returns the union of the two sets of flags.",50],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",50],[11,"bitand","","Returns the intersection between the two sets of flags.",50],[11,"sub","","Returns the set difference of the two sets of flags.",50],[11,"not","","Returns the complement of this set of flags.",50],[11,"fmt","","",51],[11,"hash","nix::sys::stat","",52],[11,"cmp","","",52],[11,"partial_cmp","","",52],[11,"lt","","",52],[11,"le","","",52],[11,"gt","","",52],[11,"ge","","",52],[11,"clone","","",52],[11,"eq","","",52],[11,"ne","","",52],[11,"empty","","Returns an empty set of flags.",52],[11,"all","","Returns the set containing all flags.",52],[11,"bits","","Returns the raw value of the flags currently stored.",52],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",52],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",52],[11,"is_empty","","Returns `true` if no flags are currently stored.",52],[11,"is_all","","Returns `true` if all flags are currently set.",52],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",52],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",52],[11,"insert","","Inserts the specified flags in-place.",52],[11,"remove","","Removes the specified flags in-place.",52],[11,"toggle","","Toggles the specified flags in-place.",52],[11,"bitor","","Returns the union of the two sets of flags.",52],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",52],[11,"bitand","","Returns the intersection between the two sets of flags.",52],[11,"sub","","Returns the set difference of the two sets of flags.",52],[11,"not","","Returns the complement of this set of flags.",52],[11,"hash","","",53],[11,"cmp","","",53],[11,"partial_cmp","","",53],[11,"lt","","",53],[11,"le","","",53],[11,"gt","","",53],[11,"ge","","",53],[11,"clone","","",53],[11,"eq","","",53],[11,"ne","","",53],[11,"empty","","Returns an empty set of flags.",53],[11,"all","","Returns the set containing all flags.",53],[11,"bits","","Returns the raw value of the flags currently stored.",53],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",53],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",53],[11,"is_empty","","Returns `true` if no flags are currently stored.",53],[11,"is_all","","Returns `true` if all flags are currently set.",53],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",53],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",53],[11,"insert","","Inserts the specified flags in-place.",53],[11,"remove","","Removes the specified flags in-place.",53],[11,"toggle","","Toggles the specified flags in-place.",53],[11,"bitor","","Returns the union of the two sets of flags.",53],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",53],[11,"bitand","","Returns the intersection between the two sets of flags.",53],[11,"sub","","Returns the set difference of the two sets of flags.",53],[11,"not","","Returns the complement of this set of flags.",53],[11,"fmt","","",52],[11,"hash","nix::sys::termios::ffi::consts","",54],[11,"cmp","","",54],[11,"partial_cmp","","",54],[11,"lt","","",54],[11,"le","","",54],[11,"gt","","",54],[11,"ge","","",54],[11,"clone","","",54],[11,"eq","","",54],[11,"ne","","",54],[11,"empty","","Returns an empty set of flags.",54],[11,"all","","Returns the set containing all flags.",54],[11,"bits","","Returns the raw value of the flags currently stored.",54],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",54],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",54],[11,"is_empty","","Returns `true` if no flags are currently stored.",54],[11,"is_all","","Returns `true` if all flags are currently set.",54],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",54],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",54],[11,"insert","","Inserts the specified flags in-place.",54],[11,"remove","","Removes the specified flags in-place.",54],[11,"toggle","","Toggles the specified flags in-place.",54],[11,"bitor","","Returns the union of the two sets of flags.",54],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",54],[11,"bitand","","Returns the intersection between the two sets of flags.",54],[11,"sub","","Returns the set difference of the two sets of flags.",54],[11,"not","","Returns the complement of this set of flags.",54],[11,"hash","","",55],[11,"cmp","","",55],[11,"partial_cmp","","",55],[11,"lt","","",55],[11,"le","","",55],[11,"gt","","",55],[11,"ge","","",55],[11,"clone","","",55],[11,"eq","","",55],[11,"ne","","",55],[11,"empty","","Returns an empty set of flags.",55],[11,"all","","Returns the set containing all flags.",55],[11,"bits","","Returns the raw value of the flags currently stored.",55],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",55],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",55],[11,"is_empty","","Returns `true` if no flags are currently stored.",55],[11,"is_all","","Returns `true` if all flags are currently set.",55],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",55],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",55],[11,"insert","","Inserts the specified flags in-place.",55],[11,"remove","","Removes the specified flags in-place.",55],[11,"toggle","","Toggles the specified flags in-place.",55],[11,"bitor","","Returns the union of the two sets of flags.",55],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",55],[11,"bitand","","Returns the intersection between the two sets of flags.",55],[11,"sub","","Returns the set difference of the two sets of flags.",55],[11,"not","","Returns the complement of this set of flags.",55],[11,"hash","","",56],[11,"cmp","","",56],[11,"partial_cmp","","",56],[11,"lt","","",56],[11,"le","","",56],[11,"gt","","",56],[11,"ge","","",56],[11,"clone","","",56],[11,"eq","","",56],[11,"ne","","",56],[11,"empty","","Returns an empty set of flags.",56],[11,"all","","Returns the set containing all flags.",56],[11,"bits","","Returns the raw value of the flags currently stored.",56],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",56],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",56],[11,"is_empty","","Returns `true` if no flags are currently stored.",56],[11,"is_all","","Returns `true` if all flags are currently set.",56],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",56],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",56],[11,"insert","","Inserts the specified flags in-place.",56],[11,"remove","","Removes the specified flags in-place.",56],[11,"toggle","","Toggles the specified flags in-place.",56],[11,"bitor","","Returns the union of the two sets of flags.",56],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",56],[11,"bitand","","Returns the intersection between the two sets of flags.",56],[11,"sub","","Returns the set difference of the two sets of flags.",56],[11,"not","","Returns the complement of this set of flags.",56],[11,"hash","","",57],[11,"cmp","","",57],[11,"partial_cmp","","",57],[11,"lt","","",57],[11,"le","","",57],[11,"gt","","",57],[11,"ge","","",57],[11,"clone","","",57],[11,"eq","","",57],[11,"ne","","",57],[11,"empty","","Returns an empty set of flags.",57],[11,"all","","Returns the set containing all flags.",57],[11,"bits","","Returns the raw value of the flags currently stored.",57],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",57],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",57],[11,"is_empty","","Returns `true` if no flags are currently stored.",57],[11,"is_all","","Returns `true` if all flags are currently set.",57],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",57],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",57],[11,"insert","","Inserts the specified flags in-place.",57],[11,"remove","","Removes the specified flags in-place.",57],[11,"toggle","","Toggles the specified flags in-place.",57],[11,"bitor","","Returns the union of the two sets of flags.",57],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",57],[11,"bitand","","Returns the intersection between the two sets of flags.",57],[11,"sub","","Returns the set difference of the two sets of flags.",57],[11,"not","","Returns the complement of this set of flags.",57],[11,"sysname","nix::sys::utsname","",58],[11,"nodename","","",58],[11,"release","","",58],[11,"version","","",58],[11,"machine","","",58],[11,"hash","nix::sys::wait","",59],[11,"cmp","","",59],[11,"partial_cmp","","",59],[11,"lt","","",59],[11,"le","","",59],[11,"gt","","",59],[11,"ge","","",59],[11,"clone","","",59],[11,"eq","","",59],[11,"ne","","",59],[11,"empty","","Returns an empty set of flags.",59],[11,"all","","Returns the set containing all flags.",59],[11,"bits","","Returns the raw value of the flags currently stored.",59],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",59],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",59],[11,"is_empty","","Returns `true` if no flags are currently stored.",59],[11,"is_all","","Returns `true` if all flags are currently set.",59],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",59],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",59],[11,"insert","","Inserts the specified flags in-place.",59],[11,"remove","","Removes the specified flags in-place.",59],[11,"toggle","","Toggles the specified flags in-place.",59],[11,"bitor","","Returns the union of the two sets of flags.",59],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",59],[11,"bitand","","Returns the intersection between the two sets of flags.",59],[11,"sub","","Returns the set difference of the two sets of flags.",59],[11,"not","","Returns the complement of this set of flags.",59],[11,"as_slice","nix::sys::uio","",60],[11,"from_slice","","",60],[11,"from_mut_slice","","",60],[11,"is_child","nix::unistd","",61],[11,"is_parent","","",61],[11,"as_ext_str","std::ffi::os_str","",62],[8,"Socket","mio::net",""],[11,"linger","","",63],[11,"set_linger","","",63],[11,"set_reuseaddr","","",63],[11,"set_reuseport","","",63],[11,"set_tcp_nodelay","","",63],[8,"MulticastSocket","",""],[11,"join_multicast_group","","",64],[11,"leave_multicast_group","","",64],[11,"set_multicast_ttl","","",64],[8,"UnconnectedSocket","",""],[10,"send_to","","",65],[10,"recv_from","","",65],[0,"util","mio","Utilities for non-blocking IO programs"],[3,"BoundedQueue","mio::util",""],[3,"Slab","","A preallocated chunk of memory for storing objects of the same type."],[11,"with_capacity","","",66],[11,"push","","",66],[11,"pop","","",66],[11,"clone","","",66],[11,"new","","",67],[11,"new_starting_at","","",67],[11,"count","","",67],[11,"is_empty","","",67],[11,"remaining","","",67],[11,"has_remaining","","",67],[11,"contains","","",67],[11,"get","","",67],[11,"get_mut","","",67],[11,"insert","","",67],[11,"remove","","Releases the given slot",67],[11,"index","","",67],[11,"index_mut","","",67],[11,"fmt","","",67],[11,"drop","","",67],[11,"clone","mio","",2],[11,"eq","","",2],[11,"ne","","",2],[11,"fmt","","",2],[11,"clone","","",4],[11,"eq","","",4],[11,"ne","","",4],[11,"fmt","","",4],[11,"eof","","",2],[11,"buf_underflow","","",2],[11,"buf_overflow","","",2],[11,"other","","",2],[11,"from_nix_error","","",2],[11,"is_eof","","",2],[11,"is_would_block","","",2],[11,"is_buf_underflow","","",2],[11,"is_buf_overflow","","",2],[11,"as_io_error","","",2],[11,"fmt","","",3],[11,"clone","","",3],[11,"default","","",3],[11,"fmt","","",68],[11,"new","","Initializes a new event loop using default configuration settings. The\nevent loop will not be running yet.",68],[11,"configured","","",68],[11,"channel","","Returns a sender that allows sending messages to the event loop in a\nthread-safe way, waking up the event loop if needed.",68],[11,"timeout","","Schedules a timeout after the requested time interval. When the\nduration has been reached,\n[Handler::timeout](trait.Handler.html#method.timeout) will be invoked\npassing in the supplied token.",68],[11,"clear_timeout","","If the supplied timeout has not been triggered, cancel it such that it\nwill not be triggered in the future.",68],[11,"shutdown","","Tells the event loop to exit after it is done handling all events in the\ncurrent iteration.",68],[11,"register","","Registers an IO handle with the event loop.",68],[11,"register_opt","","Registers an IO handle with the event loop.",68],[11,"reregister","","Re-Registers an IO handle with the event loop.",68],[11,"run","","Keep spinning the event loop indefinitely, and notify the handler whenever\nany of the registered handles are ready.",68],[11,"deregister","","Deregisters an IO handle with the event loop.",68],[11,"run_once","","Spin the event loop once, with a timeout of one second, and notify the\nhandler if any of the registered handles become ready during that\ntime.",68],[11,"clone","","",69],[11,"fmt","","",69],[11,"send","","",69],[11,"fmt","","",5],[11,"would_block","","",5],[11,"unwrap","","",5],[11,"fmt","","",70],[11,"new","","",70],[11,"fd","","",70],[11,"read_slice","","",70],[11,"write_slice","","",70],[11,"drop","","",70],[11,"from_fd","","",71],[11,"fd","","",71],[11,"read_slice","","",71],[11,"from_fd","","",72],[11,"fd","","",72],[11,"write_slice","","",72],[11,"cmp","","",73],[11,"partial_cmp","","",73],[11,"lt","","",73],[11,"le","","",73],[11,"gt","","",73],[11,"ge","","",73],[11,"clone","","",73],[11,"eq","","",73],[11,"ne","","",73],[11,"edge","","",73],[11,"empty","","",73],[11,"level","","",73],[11,"oneshot","","",73],[11,"all","","",73],[11,"is_edge","","",73],[11,"is_level","","",73],[11,"is_oneshot","","",73],[11,"bits","","",73],[11,"contains","","",73],[11,"insert","","",73],[11,"remove","","",73],[11,"bitor","","",73],[11,"bitxor","","",73],[11,"bitand","","",73],[11,"sub","","",73],[11,"not","","",73],[11,"fmt","","",73],[11,"cmp","","",74],[11,"partial_cmp","","",74],[11,"lt","","",74],[11,"le","","",74],[11,"gt","","",74],[11,"ge","","",74],[11,"clone","","",74],[11,"eq","","",74],[11,"ne","","",74],[11,"none","","",74],[11,"readable","","",74],[11,"writable","","",74],[11,"error","","",74],[11,"hup","","",74],[11,"hinted","","",74],[11,"all","","",74],[11,"is_readable","","",74],[11,"is_writable","","",74],[11,"is_error","","",74],[11,"is_hup","","",74],[11,"is_hinted","","",74],[11,"insert","","",74],[11,"remove","","",74],[11,"bits","","",74],[11,"contains","","",74],[11,"bitor","","",74],[11,"bitxor","","",74],[11,"bitand","","",74],[11,"sub","","",74],[11,"not","","",74],[11,"fmt","","",74],[11,"cmp","","",75],[11,"partial_cmp","","",75],[11,"lt","","",75],[11,"le","","",75],[11,"gt","","",75],[11,"ge","","",75],[11,"clone","","",75],[11,"eq","","",75],[11,"ne","","",75],[11,"none","","",75],[11,"all","","",75],[11,"data","","",75],[11,"hup","","",75],[11,"error","","",75],[11,"is_data","","",75],[11,"is_hup","","",75],[11,"is_error","","",75],[11,"insert","","",75],[11,"remove","","",75],[11,"contains","","",75],[11,"bits","","",75],[11,"bitor","","",75],[11,"bitxor","","",75],[11,"bitand","","",75],[11,"sub","","",75],[11,"not","","",75],[11,"fmt","","",75],[11,"hash","","",76],[11,"eq","","",76],[11,"ne","","",76],[11,"fmt","","",76],[11,"clone","","",76],[11,"as_usize","","",76],[11,"new","","",77],[11,"register","","",77],[11,"reregister","","",77],[11,"deregister","","",77],[11,"poll","","",77],[11,"event","","",77],[11,"iter","","",77],[11,"fmt","","",77],[11,"fmt","","",78],[0,"buf","",""],[8,"Buf","mio::buf","A trait for values that provide sequential read access to bytes."],[10,"remaining","","Returns the number of bytes that can be accessed from the Buf",0],[10,"bytes","","Returns a slice starting at the current Buf position and of length\nbetween 0 and `Buf::remaining()`.",0],[10,"advance","","Advance the internal cursor of the Buf",0],[10,"has_remaining","","Returns true if there are any more bytes to consume",0],[10,"read_slice","","Read bytes from the `Buf` into the given slice and advance the cursor by\nthe number of bytes read.",0],[10,"read_byte","","Read a single byte from the `Buf`",0],[8,"MutBuf","","A trait for values that provide sequential write access to bytes."],[10,"remaining","","Returns the number of bytes that can be accessed from the Buf",1],[10,"advance","","Advance the internal cursor of the Buf",1],[10,"has_remaining","","Returns true if there are any more bytes to consume",1],[10,"mut_bytes","","Returns a mutable slice starting at the current Buf position and of\nlength between 0 and `Buf::remaining()`.",1],[10,"write_slice","","Read bytes from this Buf into the given slice and advance the cursor by\nthe number of bytes read.",1],[10,"write_byte","","Write a single byte to the `MuBuf`",1],[11,"from_slice","bytes::byte_buf","Create a new `ByteBuf` by copying the contents of the given slice.",79],[11,"mut_with_capacity","","",79],[11,"none","","",79],[11,"from_mem_ref","","",79],[11,"capacity","","",79],[11,"flip","","",79],[11,"read_slice","","",79],[11,"to_seq_byte_str","","",79],[11,"to_bytes","","",79],[11,"new","bytes::alloc","",80],[11,"none","","",80],[11,"is_none","","",80],[11,"ptr","","",80],[11,"bytes","","",80],[11,"bytes_mut","","",80],[11,"clone","","",80],[11,"drop","","",80],[11,"allocate","","",81],[11,"deallocate","","",81],[11,"allocate","","",81],[11,"deallocate","","",81],[11,"remaining","bytes::byte_buf","",79],[11,"bytes","","",79],[11,"advance","","",79],[11,"read_slice","","",79],[11,"from_mem_ref","","",82],[11,"to_seq_byte_str","","",82],[11,"to_bytes","","",82],[11,"remaining","","",82],[11,"bytes","","",82],[11,"advance","","",82],[11,"read_slice","","",82],[11,"capacity","","",83],[11,"flip","","",83],[11,"clear","","",83],[11,"write_slice","","",83],[11,"remaining","","",83],[11,"advance","","",83],[11,"mut_bytes","","",83],[11,"from_slice","bytes::byte_str","Create a new `SeqByteStr` from a byte slice.",84],[11,"from_mem_ref","","Creates a new `SeqByteStr` from a `MemRef`, an offset, and a length.",84],[6,"Buf","mio::buf",""],[11,"buf","bytes::byte_str","",84],[11,"concat","","",84],[11,"len","","",84],[11,"slice","","",84],[11,"to_bytes","","",84],[6,"Output","mio::buf",""],[11,"index","bytes::byte_str","",84],[11,"clone","","",84],[11,"clone","","",85],[11,"zero","","",85],[11,"from_slice","","",85],[6,"Buf","mio::buf",""],[11,"buf","bytes::byte_str","",85],[11,"concat","","",85],[11,"len","","",85],[11,"slice","","",85],[11,"split_at","","",85],[11,"to_bytes","","",85],[6,"Output","mio::buf",""],[11,"index","bytes::byte_str","",85],[11,"clone","","",86],[11,"remaining","","",86],[11,"bytes","","",86],[11,"advance","","",86],[11,"from_slice","bytes::bytes","",87],[11,"of","","",87],[11,"empty","","",87],[11,"downcast_ref","","If the underlying `ByteStr` is of type `B`, returns a reference to it\notherwise None.",87],[11,"try_unwrap","","If the underlying `ByteStr` is of type `B`, returns the unwraped value,\notherwise, returns the original `Bytes` as `Err`.",87],[6,"Buf","mio::buf",""],[11,"buf","bytes::bytes","",87],[11,"concat","","",87],[11,"len","","",87],[11,"slice","","",87],[11,"split_at","","",87],[11,"to_bytes","","",87],[6,"Output","mio::buf",""],[11,"index","bytes::bytes","",87],[11,"clone","","",87],[11,"drop","","",87],[11,"new","bytes::ring","",88],[11,"is_full","","",88],[11,"is_empty","","",88],[11,"capacity","","",88],[11,"reader","","",88],[11,"writer","","",88],[11,"clone","","",88],[11,"fmt","","",88],[11,"drop","","",88],[11,"remaining","","",89],[11,"bytes","","",89],[11,"advance","","",89],[11,"remaining","","",90],[11,"advance","","",90],[11,"mut_bytes","","",90],[11,"from_slice","bytes::rope","",91],[11,"of","","Returns a Rope consisting of the supplied Bytes as a single segment.",91],[11,"len","","",91],[11,"is_empty","","",91],[6,"Buf","mio::buf",""],[11,"buf","bytes::rope","",91],[11,"concat","","",91],[11,"len","","",91],[11,"slice","","",91],[11,"to_bytes","","",91],[6,"Output","mio::buf",""],[11,"index","bytes::rope","",91],[11,"clone","","",91],[6,"Error","mio::buf",""],[11,"remaining","bytes::rope","",92],[11,"bytes","","",92],[11,"advance","","",92],[6,"Item","mio::buf",""],[11,"next","bytes::rope","",93],[11,"wrap","bytes::slice","",94],[11,"remaining","","",94],[11,"bytes","","",94],[11,"advance","","",94],[11,"wrap","","",95],[11,"remaining","","",95],[11,"advance","","",95],[11,"mut_bytes","","",95],[6,"Error","mio::buf",""],[6,"Error","",""],[6,"Error","",""],[6,"Error","",""],[6,"Error","",""],[6,"Error","",""],[6,"Error","",""],[11,"remaining","alloc::boxed","",96],[11,"bytes","","",96],[11,"advance","","",96],[11,"read_slice","","",96],[11,"fmt","bytes","",97],[3,"ByteBuf","mio::buf","A `Buf` backed by a contiguous region of memory."],[3,"MutByteBuf","",""],[3,"RingBuf","","Buf backed by a continous chunk of memory. Maintains a read cursor and a\nwrite cursor. When reads and writes reach the end of the allocated buffer,\nwraps around to the start."],[3,"RingBufReader","",""],[3,"RingBufWriter","",""],[3,"SliceBuf","",""],[3,"MutSliceBuf","",""],[6,"MioResult","mio",""],[6,"TimerResult","",""],[8,"Handler","",""],[11,"readable","","",98],[11,"writable","","",98],[11,"notify","","",98],[11,"timeout","","",98],[8,"FromFd","",""],[10,"from_fd","","",99],[8,"TryRead","",""],[11,"read","","",100],[10,"read_slice","","",100],[8,"TryWrite","",""],[11,"write","","",101],[10,"write_slice","","",101],[8,"IoAcceptor","",""],[16,"Output","mio::IoAcceptor",""],[10,"accept","mio","",102],[8,"IoHandle","",""],[10,"fd","","",103],[11,"readable","","",98],[11,"writable","","",98],[11,"notify","","",98],[11,"timeout","","",98],[11,"read","","",100],[11,"write","","",101]],"paths":[[8,"Buf"],[8,"MutBuf"],[3,"MioError"],[3,"EventLoopConfig"],[4,"MioErrorKind"],[4,"NonBlock"],[3,"TcpSocket"],[3,"TcpListener"],[3,"TcpAcceptor"],[3,"UdpSocket"],[3,"UnixSocket"],[3,"UnixListener"],[3,"UnixAcceptor"],[4,"NixError"],[3,"Path"],[3,"PathBuf"],[4,"Errno"],[3,"OFlag"],[3,"FdFlag"],[3,"MsFlags"],[3,"MntFlags"],[3,"CpuSet"],[3,"EpollEventKind"],[3,"EventFdFlag"],[3,"Winsize"],[3,"SockFlag"],[3,"SigSet"],[3,"SigAction"],[4,"AddressFamily"],[4,"InetAddr"],[4,"IpAddr"],[3,"Ipv4Addr"],[3,"Ipv6Addr"],[3,"UnixAddr"],[4,"SockAddr"],[3,"ip_mreq"],[3,"ReuseAddr"],[3,"ReusePort"],[3,"TcpNoDelay"],[3,"Linger"],[3,"IpAddMembership"],[3,"IpDropMembership"],[3,"IpMulticastTtl"],[3,"GetStruct"],[3,"SetStruct"],[3,"GetBool"],[3,"SetBool"],[3,"GetU8"],[3,"SetU8"],[4,"SockType"],[3,"SockFlag"],[3,"linger"],[3,"SFlag"],[3,"Mode"],[3,"InputFlags"],[3,"OutputFlags"],[3,"ControlFlags"],[3,"LocalFlags"],[3,"UtsName"],[3,"WaitPidFlag"],[3,"IoVec"],[4,"Fork"],[3,"OsStr"],[8,"Socket"],[8,"MulticastSocket"],[8,"UnconnectedSocket"],[3,"BoundedQueue"],[3,"Slab"],[3,"EventLoop"],[3,"EventLoopSender"],[3,"Io"],[3,"PipeReader"],[3,"PipeWriter"],[3,"PollOpt"],[3,"Interest"],[3,"ReadHint"],[3,"Token"],[3,"Poll"],[3,"TimerError"],[3,"ByteBuf"],[3,"MemRef"],[3,"Heap"],[3,"ROByteBuf"],[3,"MutByteBuf"],[3,"SeqByteStr"],[3,"SmallByteStr"],[3,"SmallByteStrBuf"],[3,"Bytes"],[3,"RingBuf"],[3,"RingBufReader"],[3,"RingBufWriter"],[3,"Rope"],[3,"RopeBuf"],[3,"PieceIter"],[3,"SliceBuf"],[3,"MutSliceBuf"],[3,"Box"],[4,"BufError"],[8,"Handler"],[8,"FromFd"],[8,"TryRead"],[8,"TryWrite"],[8,"IoAcceptor"],[8,"IoHandle"]]};
initSearch(searchIndex);
